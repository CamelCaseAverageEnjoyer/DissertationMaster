
Громоздксть уравнений вследствие вышеупомянутых законов не позвляет решить задачу перелёта аналитически. Другой способ решения задачи это численное решение. Для этого, вводится невязка - разница между радиус-векторами аппарата и цели:
$${\Delta r} = {min} _{t} | \boldsymbol{\Delta r(t)} |, t \in [t_0, t_1],$$
где $$\boldsymbol{\Delta r}= \boldsymbol{r} - \boldsymbol{r_{1}^{ORF}} = \boldsymbol{r} - \boldsymbol{R} - \boldsymbol{S}^{T}(\boldsymbol{r}_1^{BRF} - \boldsymbol{r}_c) .$$Невязка $\boldsymbol{\Delta r}$=$\boldsymbol{\Delta r} (t, НУ, u(t))$ в каждый момент времени зависит от начальных условий и вектора управления. Единственный способ расчёта ${\Delta r}$ это задание начальных условий и численный расчёт $\boldsymbol{\Delta r}$ на зафиксированном отрезке  $$t \in [t_0, t_1],$$
где $t_1$ фиксированно или зависит от начальных условий. Если при выполнении условия столкновения $(1)$ в момент $t^*$ переопределить $t_1 = t^*$, то условие несоударения может быть учтено. 

Исходя из ограничений ориентации аппарата, задача перелёта делится на задачу отталкивания и задачу управления. Управление может быть учтено в задаче отталкивания, однако это повышает расчётные затраты без выгоды точности. Также это предположение не применимо для реальной миссии в общем случае.  Поскольку некоторые алгоритмы управления, например, ПД-регулятор, не содержат информацию об ограничениях задачи, то необходимо вводить сложный функционал в алгоритм механического отталкивания. 
Начальная скорость отталкивания $\boldsymbol{\upsilon}_0$, также как импульс при импульсном управлении, может быть найдена:
1. Градиентными методами (метод пристрелки),
2. Неградиентными методами (метод дифференциальной эволюции).
Максимально эффективно использование последовательного поиска начальных условий неградиентным и градиентным методами.

Допустим, поставленная задача задаётся функционалом:
$$f(\boldsymbol{\upsilon}_0) \to min.$$
Метод пристрелки состоит из начального приближения $\boldsymbol{\upsilon}_0$ и цикла:
-> $f(\boldsymbol{\upsilon}_0^i)$ расчитывается численно;
-> проверяется критерий останова;
-> скорость отталкивания меняется $\boldsymbol{\upsilon}_0^{i+1} = \boldsymbol{\upsilon}_0 - (\frac{\partial(\Delta r_x, \Delta r_y, \Delta r_z)}{\partial({\upsilon}_0^x, {\upsilon}_0^y, {\upsilon}_0^z)})^{-1} \boldsymbol{\Delta r}$.

Метод дифференциальной эволюции имеет список начальных значений $\boldsymbol{\upsilon}_0^{1} .. \boldsymbol{\upsilon}_0^{k}$ как начальное поколение векторов и цикл:
-> для каждого вектора $\boldsymbol{\upsilon}_0^{i}$ выбираются отличные от него $\boldsymbol{\upsilon}_0^{i1}, \boldsymbol{\upsilon}_0^{i2}, \boldsymbol{\upsilon}_0^{i3}$ среди предыдущего поколения векторов
-> генерируется мутатный вектор $\boldsymbol{\upsilon} = \boldsymbol{\upsilon}_0^{i1} + F(\boldsymbol{\upsilon}_0^{i2} - \boldsymbol{\upsilon}_0^{i3})$;
-> пробный вектор $\boldsymbol{\upsilon}_{prob}$ получается скрещиванием начального вектора $\boldsymbol{\upsilon}_0^{i}$ и мутатного $\boldsymbol{\upsilon}$: каждая координата $\boldsymbol{\upsilon}$ с вероятностью $\zeta$  заменяется соответствующей координатой $\boldsymbol{\upsilon}_0^{i}$;
-> если $f(\boldsymbol{\upsilon}_{prob}) < f(\boldsymbol{\upsilon}_{o}^i)$, то пробный вектор заменяет $\boldsymbol{\upsilon}_0^{i}$ в новом поколении, иначе $\boldsymbol{\upsilon}_0^{i}$ остаётся.
Параметры $F=[0, 2]$ и $\zeta=(0, 1)$ являются гиперпараметрами задачи.

Функция $f(\boldsymbol{\upsilon}_0)$ в задаче без ограничений может быть задана как $f^0(\boldsymbol{\upsilon}_0) = \Delta r (\boldsymbol{\upsilon}_0)$. Но существуют методы, позволяющие решать условную задачу или оптимизировать заданные функции на многооразии $\upsilon_0(f^0 = 0)$. Одним из таких методов является метод внутренней точки. Он основан на модификации целевого функционала:
$$ f(\boldsymbol{\upsilon}_0) = \Delta r - \mu \sum_{i=1}^m log(c_i (\boldsymbol{\upsilon}_0)) $$
где $с_i(x) > 0,$ $i = 1..m,$ - условия задачи. Метод внутренней точки устремляет значение импульса к многообразию $\upsilon_0(f^0 = 0)$  только в том случае, если каждый шаг цикла уменьшает параметр $\mu$ к нулю. Однако этот метод предполагает постоянного выполнения ограничений. В ином случае, целевой функционал не может быть посчитан. В случае итерационных методов поиска $argmin(f(\boldsymbol{\upsilon}_0))$ на шаге $k$ может произойти невыполнение одного из условий: $с_i(x) \leq 0$. Для предотвращения подстановки отрицательного числа под логарифм вводится добавочные члены $\varepsilon$, $\delta$ в функционал:
$$ f(\boldsymbol{\upsilon}_0) = \Delta r - \mu \sum_{i=1}^m log(c_i (\boldsymbol{\upsilon}_0) + \varepsilon + \delta) + \varepsilon, \hskip 10px (1) $$
$$\begin{equation*} \varepsilon = \begin{cases} 0, & \forall i \to c_i > 0,\\ |\min_{i} (c_i)|, & \exists c_i \leq 0,  \end{cases} \end{equation*} $$
где $\delta$ - гиперпараметр задачи. Следовательно, для заданного алгоритма управления, задача перелёта эквивалентна задаче поиска минимума функционала ${\Delta r}(НУ, \boldsymbol{\upsilon}_0)$ или $f(НУ, \boldsymbol{\upsilon}_0)$ в пространстве $\boldsymbol{\upsilon}_0$. 

Стоит отметить, что для подзадачи отталкивания необязательно учитывать управление. Это упрощает расчёт без потери общности. Однако учёт столкновения необходим в задаче механического отталкивания. Самый тривиальный способ $-$ добавка $\xi \gg 1$ к правой части функционала $(1)$, если для данного $\boldsymbol{\upsilon}_0$ на промежутке $[t_0 + \delta_t, t_1]$ произошло столкновение аппарата с элементами конструкции. Данный способ подходит для неградиентных методов вследствие условного задания функционала. 